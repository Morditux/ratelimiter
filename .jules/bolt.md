## 2024-05-23 - Sharded Locking for High Concurrency
**Learning:** Global mutexes in both the algorithm layer (`TokenBucket`) and storage layer (`MemoryStore`) created a double bottleneck. Optimizing only one layer was insufficient because the other layer would still serialize execution. Optimizing `TokenBucket` alone yielded no results because `MemoryStore` writes serialized everything. Optimizing `MemoryStore` alone would have been useless because `TokenBucket`'s global lock was the outer gate.
**Action:** When optimizing layered systems with locks, identify if locks are nested or sequential. If sequential (like Algorithm -> Store), you must optimize *both* (or the outer one if it completely wraps the inner one). In this case, `TokenBucket` wrapped `MemoryStore` calls in a critical section, so `TokenBucket` had to be sharded. But `TokenBucket` operations involved `MemoryStore` writes, so `MemoryStore` also had to be sharded to allow concurrent writes.
